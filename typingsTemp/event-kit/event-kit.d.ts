// Type definitions for event-kit (v2.0.0)
// Project: https://github.com/atom/event-kit
// Definitions by: david-driscoll <https://github.com/david-driscoll/>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

// Generated by: https://github.com/david-driscoll/atom-typescript-generator
// Generation tool by david-driscoll <https://github.com/david-driscoll/>
declare module EventKit {
    /**
     * An object that aggregates multiple {Disposable} instances together
     * into a single disposable, so they can all be disposed as a group.
     */
    export class CompositeDisposable {
        /**
         * Construct an instance, optionally with one or more disposables 
         */
        constructor();
    
        /**
         * Dispose all disposables added to this composite disposable.
         * 
         * If this object has already been disposed, this method has no effect. 
         */
        dispose() : void;
    
        /**
         * Add disposables to be disposed when the composite is disposed.
         * 
         * If this object has already been disposed, this method has no effect.
         */
        add() : void;
    
        /**
         * Remove a previously added disposable.
         * @param disposable? - {Disposable} instance or any object with a `.dispose()` method. 
         */
        remove(disposable? : Disposable) : void;
    
        /**
         * Clear all disposables. They will not be disposed by the next call
         * to dispose. 
         */
        clear() : void;
    
    }

    /**
     * A handle to a resource that can be disposed. For example,
     * {Emitter::on} returns disposables representing subscriptions. 
     */
    export class Disposable {
        /**
         * Ensure that `object` correctly implements the `Disposable`
         * contract.
         * @param object? - An {Object} you want to perform the check against.
         */
        static isDisposable(object? : boolean) : Disposable;
    
        /**
         * Construct a Disposable
         * @param disposalAction? - A {Function} to call when {::dispose} is called for the first time. 
         */
        constructor(disposalAction? : Function);
    
        /**
         * Perform the disposal action, indicating that the resource associated
         * with this disposable is no longer needed.
         * 
         * You can call this method more than once, but the disposal action will only
         * be performed the first time. 
         */
        dispose() : void;
    
    }

    /**
     * Utility class to be used when implementing event-based APIs that
     * allows for handlers registered via `::on` to be invoked with calls to
     * `::emit`. Instances of this class are intended to be used internally by
     * classes that expose an event-based API.
     */
    export class Emitter {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static onEventHandlerException(exceptionHandler? : (...value: any[]) => void) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static simpleDispatch(handler? : (...value: any[]) => void, value? : any) : TextBuffer.Patch;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        static exceptionHandlingDispatch(handler? : (...value: any[]) => void, value? : any) : TextBuffer.Patch;
    
        /**
         * Construct an emitter.
         * 
         * ```coffee
         * @emitter = new Emitter()
         * ```
         */
        constructor();
    
        /**
         * Clear out any existing subscribers. 
         */
        clear() : void;
    
        /**
         * Unsubscribe all handlers. 
         */
        dispose() : void;
    
        /**
         * Register the given handler function to be invoked whenever events by
         * the given name are emitted via {::emit}.
         * @param eventName - {String} naming the event that you want to invoke the handler when emitted.
         * @param handler? - {Function} to invoke when {::emit} is called with the given event name.
         * Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
         */
        on(eventName : string, handler? : (...value: any[]) => void, unshift? : any) : Disposable;
    
        /**
         * Register the given handler function to be invoked *before* all
         * other handlers existing at the time of subscription whenever events by the
         * given name are emitted via {::emit}.
         * 
         * Use this method when you need to be the first to handle a given event. This
         * could be required when a data structure in a parent object needs to be
         * updated before third-party event handlers registered on a child object via a
         * public API are invoked. Your handler could itself be preempted via
         * subsequent calls to this method, but this can be controlled by keeping
         * methods based on `::preempt` private.
         * @param eventName - {String} naming the event that you want to invoke the handler when emitted.
         * @param handler? - {Function} to invoke when {::emit} is called with the given event name.
         * Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
         */
        preempt(eventName : string, handler? : (...value: any[]) => void) : Disposable;
    
        /**
         * Used by the disposable. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        off(eventName : string, handlerToRemove? : (...value: any[]) => void) : void;
    
        /**
         * Invoke handlers registered via {::on} for the given event name.
         * @param eventName - The name of the event to emit. Handlers registered with {::on} for the same name will be invoked.
         * @param ...value - Callbacks will be invoked with this value as an argument. 
         */
        emit(eventName : string, ...value : any[]) : void;
    
    }

}
declare module "event-kit" {
    class CompositeDisposable extends EventKit.CompositeDisposable {}
    class Disposable extends EventKit.Disposable {}
    class Emitter extends EventKit.Emitter {}
}
