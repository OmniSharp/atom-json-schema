// Type definitions for pathwatcher (v6.5.0)
// Project: https://github.com/atom/node-pathwatcher
// Definitions by: david-driscoll <https://github.com/david-driscoll/>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

// Generated by: https://github.com/david-driscoll/atom-typescript-generator
// Generation tool by david-driscoll <https://github.com/david-driscoll/>
/// <reference path="../event-kit/event-kit.d.ts" />
declare module Pathwatcher {
    /**
     * Represents a directory on disk that can be watched for changes. 
     */
    export class Directory {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        symlink: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        realPath: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscriptionCount: number;
    
        /**
         * Configures a new Directory instance, no files are accessed.
         * @param directoryPath? - A {String} containing the absolute path to the directory
         * @param symlink? - A {Boolean} indicating if the path is a symlink. (default: false) 
         */
        constructor(directoryPath? : string, symlink? : boolean);
    
        /**
         * Creates the directory on disk that corresponds to `::getPath()` if
         * no such directory already exists.
         * Returns a {Promise} that resolves once the directory is created on disk. It
         * resolves to a boolean value that is true if the directory was created or
         * false if it already existed.
         */
        create(mode? : any) : Q.Promise<any>;
    
        /**
         * Invoke the given callback when the directory's contents change.
         * @param callback - {Function} to be called when the directory's contents change.
         */
        onDidChange(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        willAddSubscription() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didRemoveSubscription() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        trackUnsubscription(subscription? : any) : any;
    
        isFile() : File;
    
        isDirectory() : Directory;
    
        isSymbolicLink() : boolean;
    
        exists() : boolean;
    
        existsSync() : boolean;
    
        /**
         * Return a {Boolean}, true if this {Directory} is the root directory
         * of the filesystem, or false if it isn't. 
         */
        isRoot() : boolean;
    
        /**
         * 
         * 
         * This may include unfollowed symlinks or relative directory entries. Or it
         * may be fully resolved, it depends on what you give it. 
         */
        getPath() : string;
    
        /**
         * 
         * 
         * All relative directory entries are removed and symlinks are resolved to
         * their final destination. 
         */
        getRealPathSync() : string;
    
        getBaseName() : string;
    
        relativize(fullPath? : string) : string;
    
        /**
         * Given a relative path, this resolves it to an absolute path relative to this
         * directory. If the path is already absolute or prefixed with a URI scheme, it
         * is returned unchanged.
         * This field or method was marked private by atomdoc. Use with caution.
         * Returns a {String} containing an absolute path or `` if the given
         * URI is falsy.
         */
        resolve(relativePath? : string) : string;
    
        /**
         * Traverse to the parent directory.
         * Returns a {Directory}.
         */
        getParent() : Directory;
    
        /**
         * Traverse within this Directory to a child File. This method doesn't
         * actually check to see if the File exists, it just creates the File object.
         */
        getFile(filename? : string) : File;
    
        /**
         * Traverse within this a Directory to a child Directory. This method
         * doesn't actually check to see if the Directory exists, it just creates the
         * Directory object.
         */
        getSubdirectory(dirname? : string) : Directory;
    
        /**
         * Reads file entries in this directory from disk synchronously.
         * Returns an {Array} of {File} and {Directory} objects.
         */
        getEntriesSync() : File[];
    
        /**
         * Reads file entries in this directory from disk asynchronously.
         * @param callback? - A {Function} to call with the following arguments:
         */
        getEntries(callback? : Function) : any;
    
        /**
         * Determines if the given path (real or symbolic) is inside this
         * directory. This method does not actually check if the path exists, it just
         * checks if the path is under this directory.
         * @param pathToCheck? - The {String} path to check.
         * Returns a {Boolean} whether the given path is inside this directory.
         */
        contains(pathToCheck? : string) : boolean;
    
        /**
         * Private
         * This field or method was marked private by atomdoc. Use with caution.
         */
        subscribeToNativeChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unsubscribeFromNativeChangeEvents() : any;
    
        /**
         * Does given full path start with the given prefix? 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        isPathPrefixOf(prefix? : boolean, fullPath? : string) : string;
    
    }

    /**
     * Represents an individual file that can be watched, read from, and
     * written to. 
     */
    export class File {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        symlink: any /* default */;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        encoding: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        realPath: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscriptionCount: number;
    
        /**
         * Configures a new File instance, no files are accessed.
         * @param filePath? - A {String} containing the absolute path to the file
         * @param symlink? - A {Boolean} indicating if the path is a symlink (default: false). 
         */
        constructor(filePath? : string, symlink? : boolean);
    
        /**
         * Creates the file on disk that corresponds to `::getPath()` if no
         * such file already exists.
         * Returns a {Promise} that resolves once the file is created on disk. It
         * resolves to a boolean value that is true if the file was created or false if
         * it already existed.
         */
        create() : Q.Promise<any>;
    
        /**
         * Invoke the given callback when the file's contents change.
         * @param callback - {Function} to be called when the file's contents change.
         */
        onDidChange(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the file's path changes.
         * @param callback - {Function} to be called when the file's path changes.
         */
        onDidRename(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when the file is deleted.
         * @param callback - {Function} to be called when the file is deleted.
         */
        onDidDelete(callback : Function /* needs to be defined */) : EventKit.Disposable;
    
        /**
         * Invoke the given callback when there is an error with the watch.
         * When your callback has been invoked, the file will have unsubscribed from
         * the file watches.
         * @param callback - {Function} callback
         */
        onWillThrowWatchError(callback : Function) : EventKit.Disposable;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        willAddSubscription() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        didRemoveSubscription() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        trackUnsubscription(subscription? : any) : any;
    
        isFile() : File;
    
        isDirectory() : Directory;
    
        isSymbolicLink() : boolean;
    
        exists() : boolean;
    
        existsSync() : boolean;
    
        /**
         * Get the SHA-1 digest of this file
         * Returns a promise that resolves to a {String}.
         */
        getDigest() : string;
    
        /**
         * Get the SHA-1 digest of this file
         * Returns a {String}.
         */
        getDigestSync() : string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        setDigest(contents? : any) : void;
    
        /**
         * Sets the file's character set encoding name.
         * @param encoding? - The {String} encoding to use (default: 'utf8') 
         */
        setEncoding(encoding? : string) : string;
    
        getEncoding() : string;
    
        getPath() : string;
    
        /**
         * Sets the path for the file. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        setPath(path? : string) : string;
    
        getRealPathSync() : string;
    
        getRealPath() : string;
    
        /**
         * Return the {String} filename without any directory information. 
         */
        getBaseName() : string;
    
        /**
         * Return the {Directory} that contains this file. 
         */
        getParent() : any;
    
        /**
         * Reading and Writing
         * This field or method was marked private by atomdoc. Use with caution.
         */
        readSync(flushCache? : any) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        writeFileSync(filePath? : string, contents? : any) : any;
    
        /**
         * Reads the contents of the file.
         * @param flushCache? - A {Boolean} indicating whether to require a direct read or if a cached copy is acceptable.
         * Returns a promise that resolves to a String.
         */
        read(flushCache? : boolean) : any;
    
        createReadStream() : any/* | ReadStream*/;
    
        /**
         * Overwrites the file with the given text.
         * @param text? - The {String} text to write to the underlying file.
         * Returns a {Promise} that resolves when the file has been written.
         */
        write(text? : string) : Q.Promise<any>;
    
        createWriteStream() : any/* | WriteStream*/;
    
        /**
         * Overwrites the file with the given text.
         * @param text? - The {String} text to write to the underlying file.
         * Returns .
         */
        writeSync(text? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        writeFile(filePath? : string, contents? : any) : File;
    
        /**
         * Writes the text to specified path.
         * 
         * Privilege escalation would be asked when current user doesn't have
         * permission to the path. 
         * This field or method was marked private by atomdoc. Use with caution.
         */
        writeFileWithPrivilegeEscalationSync(filePath? : string, text? : string) : any;
    
        /**
         * Private
         * This field or method was marked private by atomdoc. Use with caution.
         */
        handleNativeChangeEvent(eventType? : any, eventPath? : string) : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        detectResurrectionAfterDelay() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        detectResurrection() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        subscribeToNativeChangeEvents() : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        unsubscribeFromNativeChangeEvents() : any;
    
    }

    /**
     * HandleWatcher
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class HandleWatcher /*extends NodeJS.EventEmitter*/ {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        path: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(path? : string);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        onEvent(event? : any, filePath? : string, oldFilePath? : string) : any;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        start() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        closeIfNoListener() : void;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        close() : void;
    
    }

    /**
     * PathWatcher
     * This class was not documented by atomdoc, assume it is private. Use with caution.
     */
    class PathWatcher /*extends NodeJS.EventEmitter*/ {
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        isWatchingParent: boolean;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        path: string;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        handleWatcher: HandleWatcher;
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        constructor(filePath? : string, callback? : any);
    
        /**
         * This field or method was not documented by atomdoc, assume it is private. Use with caution.
         */
        close() : void;
    
    }

}
declare module "pathwatcher" {
    class Directory extends Pathwatcher.Directory {}
    class File extends Pathwatcher.File {}
    function watch(path:string, callback?: (event: any, newFilePath: string) => void ) : any;
    function closeAllWatchers() : void;
    function getWatchedPaths() : string[];
}
