'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.provider = undefined;

var _jsonSchemaService = require('./vscode/plugin/jsonSchemaService');

var _jsonParser = require('./vscode/plugin/jsonParser');

var Range = require('atom').Range;

var jsonSchemaService = new _jsonSchemaService.JSONSchemaService();
var provider = exports.provider = [{
    grammarScopes: ['source.json'],
    scope: 'file',
    lintOnFly: true,
    lint: function lint(editor) {
        if (editor.getText().length === 0) {
            return Promise.resolve([]);
        }
        var jsonDocument = (0, _jsonParser.parse)(editor.getText());
        return jsonSchemaService.getSchemaForResource(editor.getURI(), jsonDocument).then(function (schema) {
            if (schema) {
                if (schema.errors.length && jsonDocument.root) {
                    var astRoot = jsonDocument.root;
                    var property = astRoot.type === 'object' ? astRoot.getFirstProperty('$schema') : null;
                    if (property) {
                        var node = property.value || property;
                        jsonDocument.warnings.push({ location: { start: node.start, end: node.end }, message: schema.errors[0] });
                    } else {
                        jsonDocument.warnings.push({ location: { start: astRoot.start, end: astRoot.start + 1 }, message: schema.errors[0] });
                    }
                } else {
                    jsonDocument.validate(schema.schema);
                }
            }
            var diagnostics = [];
            jsonDocument.errors.concat(jsonDocument.warnings).forEach(function (error, idx) {
                var signature = error.location.start + ' ' + error.location.end + ' ' + error.message;
                var location = editor.getBuffer().positionForCharacterIndex(error.location.start);
                diagnostics.push({
                    type: idx >= jsonDocument.errors.length ? "warning" : "error",
                    text: signature,
                    filePath: editor.getPath(),
                    line: location.row + 1,
                    col: location.column + 1,
                    range: new Range(error.location.start, error.location.end)
                });
            });
            return diagnostics;
        });
    }
}];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNjaGVtYS1saW50ZXIuanMiLCJzY2hlbWEtbGludGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFDQTs7QUNGQSxJQUFJLFFBQVEsUUFBUSxNQUFSLEVBQWdCLEtBQTVCOztBQVNBLElBQU0sb0JBQW9CLDBDQUExQjtBQVlPLElBQUksOEJBQVcsQ0FDbEI7QUFDSSxtQkFBZSxDQUFDLGFBQUQsQ0FEbkI7QUFFSSxXQUFPLE1BRlg7QUFHSSxlQUFXLElBSGY7QUFJSSxVQUFNLGNBQUMsTUFBRCxFQUF3QjtBQUMxQixZQUFJLE9BQU8sT0FBUCxHQUFpQixNQUFqQixLQUE0QixDQUFoQyxFQUFtQztBQUUvQixtQkFBTyxRQUFRLE9BQVIsQ0FBK0IsRUFBL0IsQ0FBUDtBQUNIO0FBRUQsWUFBSSxlQUFlLHVCQUFVLE9BQU8sT0FBUCxFQUFWLENBQW5CO0FBQ0EsZUFBTyxrQkFBa0Isb0JBQWxCLENBQXVDLE9BQU8sTUFBUCxFQUF2QyxFQUF3RCxZQUF4RCxFQUFzRSxJQUF0RSxDQUEyRSxrQkFBTTtBQUNwRixnQkFBSSxNQUFKLEVBQVk7QUFDUixvQkFBSSxPQUFPLE1BQVAsQ0FBYyxNQUFkLElBQXdCLGFBQWEsSUFBekMsRUFBK0M7QUFDM0Msd0JBQUksVUFBVSxhQUFhLElBQTNCO0FBQ0Esd0JBQUksV0FBVyxRQUFRLElBQVIsS0FBaUIsUUFBakIsR0FBNEMsUUFBUyxnQkFBVCxDQUEwQixTQUExQixDQUE1QyxHQUFtRixJQUFsRztBQUNBLHdCQUFJLFFBQUosRUFBYztBQUNWLDRCQUFJLE9BQU8sU0FBUyxLQUFULElBQWtCLFFBQTdCO0FBQ0EscUNBQWEsUUFBYixDQUFzQixJQUF0QixDQUEyQixFQUFFLFVBQVUsRUFBRSxPQUFPLEtBQUssS0FBZCxFQUFxQixLQUFLLEtBQUssR0FBL0IsRUFBWixFQUFrRCxTQUFTLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBM0QsRUFBM0I7QUFDSCxxQkFIRCxNQUdPO0FBQ0gscUNBQWEsUUFBYixDQUFzQixJQUF0QixDQUEyQixFQUFFLFVBQVUsRUFBRSxPQUFPLFFBQVEsS0FBakIsRUFBd0IsS0FBSyxRQUFRLEtBQVIsR0FBZ0IsQ0FBN0MsRUFBWixFQUE4RCxTQUFTLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBdkUsRUFBM0I7QUFDSDtBQUNKLGlCQVRELE1BU087QUFDSCxpQ0FBYSxRQUFiLENBQXNCLE9BQU8sTUFBN0I7QUFDSDtBQUNKO0FBRUQsZ0JBQUksY0FBNkIsRUFBakM7QUFDQSx5QkFBYSxNQUFiLENBQW9CLE1BQXBCLENBQTJCLGFBQWEsUUFBeEMsRUFBa0QsT0FBbEQsQ0FBMEQsVUFBQyxLQUFELEVBQVEsR0FBUixFQUFXO0FBRWpFLG9CQUFJLFlBQVksTUFBTSxRQUFOLENBQWUsS0FBZixHQUF1QixHQUF2QixHQUE2QixNQUFNLFFBQU4sQ0FBZSxHQUE1QyxHQUFrRCxHQUFsRCxHQUF3RCxNQUFNLE9BQTlFO0FBQ0Esb0JBQU0sV0FBVyxPQUFPLFNBQVAsR0FBbUIseUJBQW5CLENBQTZDLE1BQU0sUUFBTixDQUFlLEtBQTVELENBQWpCO0FBRUEsNEJBQVksSUFBWixDQUFpQjtBQUNiLDBCQUFNLE9BQU8sYUFBYSxNQUFiLENBQW9CLE1BQTNCLEdBQW9DLFNBQXBDLEdBQWdELE9BRHpDO0FBRWIsMEJBQU0sU0FGTztBQUdiLDhCQUFVLE9BQU8sT0FBUCxFQUhHO0FBSWIsMEJBQU0sU0FBUyxHQUFULEdBQWUsQ0FKUjtBQUtiLHlCQUFLLFNBQVMsTUFBVCxHQUFrQixDQUxWO0FBTWIsMkJBQU8sSUFBSSxLQUFKLENBQVUsTUFBTSxRQUFOLENBQWUsS0FBekIsRUFBZ0MsTUFBTSxRQUFOLENBQWUsR0FBL0M7QUFOTSxpQkFBakI7QUFRSCxhQWJEO0FBZUEsbUJBQU8sV0FBUDtBQUNILFNBakNNLENBQVA7QUFrQ0g7QUE3Q0wsQ0FEa0IsQ0FBZiIsImZpbGUiOiJzY2hlbWEtbGludGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFJhbmdlID0gcmVxdWlyZSgnYXRvbScpLlJhbmdlO1xuaW1wb3J0IHsgSlNPTlNjaGVtYVNlcnZpY2UgfSBmcm9tICcuL3ZzY29kZS9wbHVnaW4vanNvblNjaGVtYVNlcnZpY2UnO1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VKU09OIH0gZnJvbSAnLi92c2NvZGUvcGx1Z2luL2pzb25QYXJzZXInO1xuY29uc3QganNvblNjaGVtYVNlcnZpY2UgPSBuZXcgSlNPTlNjaGVtYVNlcnZpY2UoKTtcbmV4cG9ydCB2YXIgcHJvdmlkZXIgPSBbXG4gICAge1xuICAgICAgICBncmFtbWFyU2NvcGVzOiBbJ3NvdXJjZS5qc29uJ10sXG4gICAgICAgIHNjb3BlOiAnZmlsZScsXG4gICAgICAgIGxpbnRPbkZseTogdHJ1ZSxcbiAgICAgICAgbGludDogKGVkaXRvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVkaXRvci5nZXRUZXh0KCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQganNvbkRvY3VtZW50ID0gcGFyc2VKU09OKGVkaXRvci5nZXRUZXh0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWFTZXJ2aWNlLmdldFNjaGVtYUZvclJlc291cmNlKGVkaXRvci5nZXRVUkkoKSwganNvbkRvY3VtZW50KS50aGVuKHNjaGVtYSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9ycy5sZW5ndGggJiYganNvbkRvY3VtZW50LnJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3RSb290ID0ganNvbkRvY3VtZW50LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBhc3RSb290LnR5cGUgPT09ICdvYmplY3QnID8gYXN0Um9vdC5nZXRGaXJzdFByb3BlcnR5KCckc2NoZW1hJykgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBwcm9wZXJ0eS52YWx1ZSB8fCBwcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQud2FybmluZ3MucHVzaCh7IGxvY2F0aW9uOiB7IHN0YXJ0OiBub2RlLnN0YXJ0LCBlbmQ6IG5vZGUuZW5kIH0sIG1lc3NhZ2U6IHNjaGVtYS5lcnJvcnNbMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQud2FybmluZ3MucHVzaCh7IGxvY2F0aW9uOiB7IHN0YXJ0OiBhc3RSb290LnN0YXJ0LCBlbmQ6IGFzdFJvb3Quc3RhcnQgKyAxIH0sIG1lc3NhZ2U6IHNjaGVtYS5lcnJvcnNbMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQudmFsaWRhdGUoc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gW107XG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50LmVycm9ycy5jb25jYXQoanNvbkRvY3VtZW50Lndhcm5pbmdzKS5mb3JFYWNoKChlcnJvciwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBlcnJvci5sb2NhdGlvbi5zdGFydCArICcgJyArIGVycm9yLmxvY2F0aW9uLmVuZCArICcgJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZWRpdG9yLmdldEJ1ZmZlcigpLnBvc2l0aW9uRm9yQ2hhcmFjdGVySW5kZXgoZXJyb3IubG9jYXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGlkeCA+PSBqc29uRG9jdW1lbnQuZXJyb3JzLmxlbmd0aCA/IFwid2FybmluZ1wiIDogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IGVkaXRvci5nZXRQYXRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsb2NhdGlvbi5yb3cgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBsb2NhdGlvbi5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG5ldyBSYW5nZShlcnJvci5sb2NhdGlvbi5zdGFydCwgZXJyb3IubG9jYXRpb24uZW5kKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbl07XG4iLCJ2YXIgUmFuZ2UgPSByZXF1aXJlKCdhdG9tJykuUmFuZ2U7XHJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7b21uaX0gZnJvbSBcIi4vb21uaVwiO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gXCJyeGpzXCI7XHJcbmltcG9ydCB7Q29tcG9zaXRlRGlzcG9zYWJsZX0gZnJvbSBcIi4vZGlzcG9zYWJsZXNcIjtcclxuXHJcbmltcG9ydCB7SlNPTlNjaGVtYVNlcnZpY2UsIElTY2hlbWFBc3NvY2lhdGlvbnN9IGZyb20gJy4vdnNjb2RlL3BsdWdpbi9qc29uU2NoZW1hU2VydmljZSc7XHJcbmltcG9ydCB7cGFyc2UgYXMgcGFyc2VKU09OLCBPYmplY3RBU1ROb2RlLCBKU09ORG9jdW1lbnR9IGZyb20gJy4vdnNjb2RlL3BsdWdpbi9qc29uUGFyc2VyJztcclxuXHJcbmNvbnN0IGpzb25TY2hlbWFTZXJ2aWNlID0gbmV3IEpTT05TY2hlbWFTZXJ2aWNlKCk7XHJcblxyXG5pbnRlcmZhY2UgTGludGVyRXJyb3Ige1xyXG4gICAgdHlwZTogc3RyaW5nOyAvLyAnZXJyb3InIHwgJ3dhcm5pbmcnXHJcbiAgICB0ZXh0Pzogc3RyaW5nO1xyXG4gICAgaHRtbD86IHN0cmluZztcclxuICAgIGZpbGVQYXRoPzogc3RyaW5nO1xyXG4gICAgcmFuZ2U/OiBSYW5nZTtcclxuICAgIGxpbmU/OiBudW1iZXI7XHJcbiAgICBjb2w/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcHJvdmlkZXIgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgZ3JhbW1hclNjb3BlczogWydzb3VyY2UuanNvbiddLFxyXG4gICAgICAgIHNjb3BlOiAnZmlsZScsXHJcbiAgICAgICAgbGludE9uRmx5OiB0cnVlLFxyXG4gICAgICAgIGxpbnQ6IChlZGl0b3I6IEF0b20uVGV4dEVkaXRvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWRpdG9yLmdldFRleHQoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlbXB0eSBkb2N1bWVudHNcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmU8TGludGVyRXJyb3JbXT4oW10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQganNvbkRvY3VtZW50ID0gcGFyc2VKU09OKGVkaXRvci5nZXRUZXh0KCkpO1xyXG4gICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZWRpdG9yLmdldFVSSSgpLCBqc29uRG9jdW1lbnQpLnRoZW4oc2NoZW1hID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9ycy5sZW5ndGggJiYganNvbkRvY3VtZW50LnJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFzdFJvb3QgPSBqc29uRG9jdW1lbnQucm9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gYXN0Um9vdC50eXBlID09PSAnb2JqZWN0JyA/ICg8T2JqZWN0QVNUTm9kZT5hc3RSb290KS5nZXRGaXJzdFByb3BlcnR5KCckc2NoZW1hJykgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gcHJvcGVydHkudmFsdWUgfHwgcHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQud2FybmluZ3MucHVzaCh7IGxvY2F0aW9uOiB7IHN0YXJ0OiBub2RlLnN0YXJ0LCBlbmQ6IG5vZGUuZW5kIH0sIG1lc3NhZ2U6IHNjaGVtYS5lcnJvcnNbMF0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQud2FybmluZ3MucHVzaCh7IGxvY2F0aW9uOiB7IHN0YXJ0OiBhc3RSb290LnN0YXJ0LCBlbmQ6IGFzdFJvb3Quc3RhcnQgKyAxIH0sIG1lc3NhZ2U6IHNjaGVtYS5lcnJvcnNbMF0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQudmFsaWRhdGUoc2NoZW1hLnNjaGVtYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkaWFnbm9zdGljczogTGludGVyRXJyb3JbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50LmVycm9ycy5jb25jYXQoanNvbkRvY3VtZW50Lndhcm5pbmdzKS5mb3JFYWNoKChlcnJvciwgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZWQgbWVzc2FnZXNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gZXJyb3IubG9jYXRpb24uc3RhcnQgKyAnICcgKyBlcnJvci5sb2NhdGlvbi5lbmQgKyAnICcgKyBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZWRpdG9yLmdldEJ1ZmZlcigpLnBvc2l0aW9uRm9yQ2hhcmFjdGVySW5kZXgoZXJyb3IubG9jYXRpb24uc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaWR4ID49IGpzb25Eb2N1bWVudC5lcnJvcnMubGVuZ3RoID8gXCJ3YXJuaW5nXCIgOiBcImVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHNpZ25hdHVyZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IGVkaXRvci5nZXRQYXRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxvY2F0aW9uLnJvdyArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogbG9jYXRpb24uY29sdW1uICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG5ldyBSYW5nZShlcnJvci5sb2NhdGlvbi5zdGFydCwgZXJyb3IubG9jYXRpb24uZW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBjb21wdXRlZCBkaWFnbm9zdGljcyB0byBWU0NvZGUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3M7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
